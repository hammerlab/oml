
open Test_utils

module Gen = FGen (struct
  let largest_float = 1e3
end)

let () =
  let vs = 10 in  (* TODO: need to apply this as a map.*)
  Test.add_simple_test ~title:"we can test vectors for equality 1"
    (fun () -> Assert.is_true (equal [|1.0; 2.0; 3.0|] [|1.0; 2.0; 3.0|]));
  Test.add_simple_test ~title:"we can test vectors for equality 2"
    (fun () -> Assert.is_false (equal [|1.0; 2.0; 3.0|] [|1.0; 2.0; |]));
  Test.add_simple_test ~title:"we can test vectors for equality 3"
    (fun () -> Assert.is_false (equal [|1.0; 2.0; 3.0|] [|3.0; 2.0; 1.0 |]));
  Test.add_random_test ~title:"equality test is commutative"
    Gen.(zip2 (array (make_int 1 10) float) (array (make_int 1 10) float))
    (fun (v1, v2) ->
      equal v1 v2 = equal v2 v1)
    Spec.([just_postcond_pred is_true]);

  let pair_of_arrays = Gen.(zip2 (array_float vs) (array_float vs)) in
  let within = Util.dx *. 1e6 in (* on order of 1e-10 *)
  let equal = equal ~d:within in
  Test.add_random_test
    ~title:"Vector addition is commutative."
    pair_of_arrays
    (fun (v1, v2) -> equal (add v1 v2) (add v2 v1))
    Spec.([just_postcond_pred is_true]);

  Test.add_random_test
    ~title:"Vector scalar multiplication is additive."
    Gen.(zip3 float float (array_float vs))
    (fun (a, b, v) -> equal (mult (a +. b) v) (add (mult a v) (mult b v)))
    Spec.([just_postcond_pred is_true]);

  Test.add_random_test
    ~title:"Dot products are commutative"
    pair_of_arrays
    (fun (v1, v2) -> dot v1 v2 = dot v2 v1)
    Spec.([just_postcond_pred is_true]);

  Test.add_random_test
    ~title:"Dot products are distributive"
    Gen.(zip2 (array_float vs) pair_of_arrays)
    (fun (v1, (v2, v3)) ->
      not (Util.significantly_different_from ~d:(Util.dx *. 1e7)
            (dot v1 (add v2 v3)) (dot v1 v2 +. dot v1 v3)))
    Spec.([just_postcond_pred is_true]);
