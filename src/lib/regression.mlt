
open Kaputt.Abbreviations

(* Testing the accuracy of numerical algorithms is hard (and fun).
  Linear Regression provides an interesting example.
  There are two parameters that we use to tune the range of data to be
  generated by the tests. They give the user a gage on the accuracy of
  the algorithms. *)

let largest_float = 1e9
let order_comp = 100000.0


module OGen = struct
  include Gen
  let large   = largest_float
  let nlarge  = -1.0 *. large
  let float   = make_float nlarge large
end

let () =
  (* handy predicates
  let is_true (x : bool ) = x in *)
  let equal_floats x y  = not (Util.significantly_different_from x y) in
  let roughly_equal x y =
    let d = (Descriptive.geometric_mean [|x; y|]) /. order_comp in
    not (Util.significantly_different_from ~d x y)
  in

  (* Short cut evaluation. *)
  let lregress (a, b, pred)  =
    let resp = Array.map (fun x -> b *. x +. a) pred in
    linear_regress ~resp ~pred ()
  in

  (* useful generators. *)
  let non_zero_float    = OGen.(filter ((<>) 0.0) float) in
  let grt_zer_lss_one   = OGen.make_float (0.0 +. Util.dx) 1.0 in
  let two_ordered       = OGen.(transform (fun (x,y) -> min x y,max x y)
                                  (zip2 grt_zer_lss_one grt_zer_lss_one))
  in
  let simple_test_array =
    OGen.(lift (Array.init 100 float_of_int) "[0.;1.; ... ;99.]")
  in
  let random_test_array = OGen.(array (make_int 2 100) float) in
  let simple_lrm_inputs = OGen.(zip3 float non_zero_float simple_test_array) in
  let lrm_inputs        = OGen.(zip3 float non_zero_float random_test_array) in
  let simple_lrm_gen    = OGen.(map1 lregress to_string simple_lrm_inputs) in
  let lrm_gen           = OGen.(map1 lregress to_string lrm_inputs) in

  (* The tests. *)

  (* Even though this test is awkward, if the [linear_model]' implementation is
     hidden, this guards to against an incorrect implementation. *)
  Test.add_random_test
    ~title:"lrm models evaluate like linear models"
    OGen.(zip2 non_zero_float lrm_gen)
    (fun (x, lrm) -> eval_lrm lrm x)
    Spec.([ always =>
      (fun((x, lrm), y) ->
        equal_floats y (lrm.alpha +. lrm.beta *. x)) ]);

  Test.add_random_test
    ~title:"using linear regression on canonical [0.0 ... 99.0] data we can recover coefficients"
    ~nb_runs:1000
    simple_lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a lrm.alpha) && (roughly_equal b lrm.beta))]);

  Test.add_random_test
    ~title:"using linear regression on random float data we can recover coefficients"
    ~nb_runs:1000
    lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a lrm.alpha) && (roughly_equal b lrm.beta))]);

  (* TODO: clever test to react to variance in the predicted variable. *)

        (*
  Test.add_random_test
    ~title:"confidence intervals are symmetric around evaluation point."
    OGen.(zip3 simple_lrm_gen grt_zer_lss_one float)
    (fun (lrm, alpha_level, x) -> confidence_interval lrm ~alpha_level x)
    Spec.([ always =>
      (fun ((_lrm, _alpha, x), (lb, ub)) ->
        roughly_equal x (Util.midpoint lb ub))]);

  Test.add_random_test
    ~title:"prediction intervals grow as alpha increases."
    OGen.(zip3 simple_lrm_gen two_ordered float)
    (fun (lrm, (a1, a2), x) ->
      (*Printf.printf "our lrm %s alpha %f %f and x %f\n" (to_string lrm) a1 a2 x; *)
      prediction_interval lrm ~alpha_level:a1 x,
      prediction_interval lrm ~alpha_level:a2 x)
    Spec.([always =>
      (fun ((_lrm, _alpha_pair, x), ((lb1, ub1), (lb2, ub2))) ->
        ub2 -. lb2 > ub1 -. lb1)])

*)
